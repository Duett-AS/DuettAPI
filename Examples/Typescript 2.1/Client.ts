/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.13.2.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

namespace Duett.API {

    export class Client {
        private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
        private baseUrl: string;
        protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

        constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
            this.http = http ? http : <any>window;
            this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
        }

        /**
         * Deletes an existing Article given the specified Id.
         * @param id The Id of the Article to delete.
         * @return Success
         */
        v1DELETE(id: number): Promise<void> {
            let url_ = this.baseUrl + "/Article/v1/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");

            let options_ = <RequestInit>{
                method: "DELETE",
                headers: {
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processV1DELETE(_response);
            });
        }

        protected processV1DELETE(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404: any = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException("Not Found", status, _responseText, _headers, result404);
                });
            } else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400: any = null;
                    let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException("Bad Request", status, _responseText, _headers, result400);
                });
            } else if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            } else {
                return response.text().then((_responseText) => {
                    let resultdefault: any = null;
                    let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    resultdefault = ProblemDetails.fromJS(resultDatadefault);
                    return throwException("Error", status, _responseText, _headers, resultdefault);
                });
            }
        }

        /**
         * Patches an existing Article given the specified Id.
         * @param id The Id of the Article to patch.
         * @param body (optional) The operations to perform on ArticleCreate.
         * @return Success
         */
        v1PATCH(id: number, body: JsonPatchOperation[] | undefined): Promise<void> {
            let url_ = this.baseUrl + "/Article/v1/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");

            const content_ = JSON.stringify(body);

            let options_ = <RequestInit>{
                body: content_,
                method: "PATCH",
                headers: {
                    "Content-Type": "application/json-patch+json",
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processV1PATCH(_response);
            });
        }

        protected processV1PATCH(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400: any = null;
                    let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException("Bad Request", status, _responseText, _headers, result400);
                });
            } else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404: any = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException("Not Found", status, _responseText, _headers, result404);
                });
            } else if (status === 204) {
                return response.text().then((_responseText) => {
                    return;
                });
            } else {
                return response.text().then((_responseText) => {
                    let resultdefault: any = null;
                    let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    resultdefault = ProblemDetails.fromJS(resultDatadefault);
                    return throwException("Error", status, _responseText, _headers, resultdefault);
                });
            }
        }

        /**
         * Replaces an existing Article given the specified Id.
         * @param id The Id of the Article to replace.
         * @param body (optional) The ArticleCreate to replace the old Article from.
         * @return Success
         */
        v1PUT(id: number, body: ArticleCreate | undefined): Promise<void> {
            let url_ = this.baseUrl + "/Article/v1/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");

            const content_ = JSON.stringify(body);

            let options_ = <RequestInit>{
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json-patch+json",
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processV1PUT(_response);
            });
        }

        protected processV1PUT(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                    return;
                });
            } else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404: any = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException("Not Found", status, _responseText, _headers, result404);
                });
            } else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400: any = null;
                    let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException("Bad Request", status, _responseText, _headers, result400);
                });
            } else {
                return response.text().then((_responseText) => {
                    let resultdefault: any = null;
                    let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    resultdefault = ProblemDetails.fromJS(resultDatadefault);
                    return throwException("Error", status, _responseText, _headers, resultdefault);
                });
            }
        }

        /**
         * Gets all existing Article.
         * @param extend (optional) A list of keys on which to extend the Article, e.g. HourRegistrations, Metadata.
         * @param filter (optional) Query object used for filtering the result list. Supported operators are [EQ], [NEQ], [GT], [GTE], [LT], [LTE], [IN], [NIN], [LIKE], [BETWEEN] for value properties.
         * @return Success
         */
        v1All(extend: string[] | undefined, filter: any | undefined): Promise<Article[]> {
            let url_ = this.baseUrl + "/Article/v1?";
            if (extend === null)
                throw new Error("The parameter 'extend' cannot be null.");
            else if (extend !== undefined)
                extend && extend.forEach(item => { url_ += "extend=" + encodeURIComponent("" + item) + "&"; });
            if (filter === null)
                throw new Error("The parameter 'filter' cannot be null.");
            else if (filter !== undefined)
                url_ += "filter=" + encodeURIComponent("" + filter) + "&";
            url_ = url_.replace(/[?&]$/, "");

            let options_ = <RequestInit>{
                method: "GET",
                headers: {
                    "Accept": "text/plain"
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processV1All(_response);
            });
        }

        protected processV1All(response: Response): Promise<Article[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404: any = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException("Not Found", status, _responseText, _headers, result404);
                });
            } else if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200: any = null;
                    let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200)
                            result200!.push(Article.fromJS(item));
                    }
                    else {
                        result200 = <any>null;
                    }
                    return result200;
                });
            } else {
                return response.text().then((_responseText) => {
                    let resultdefault: any = null;
                    let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    resultdefault = ProblemDetails.fromJS(resultDatadefault);
                    return throwException("Error", status, _responseText, _headers, resultdefault);
                });
            }
        }

        /**
         * Creates a new Article.
         * @param body (optional) The ArticleCreate to create a new Article from.
         * @return Success
         */
        v1POST(body: ArticleCreate | undefined): Promise<Article> {
            let url_ = this.baseUrl + "/Article/v1";
            url_ = url_.replace(/[?&]$/, "");

            const content_ = JSON.stringify(body);

            let options_ = <RequestInit>{
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json-patch+json",
                    "Accept": "text/plain"
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processV1POST(_response);
            });
        }

        protected processV1POST(response: Response): Promise<Article> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 201) {
                return response.text().then((_responseText) => {
                    let result201: any = null;
                    let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result201 = Article.fromJS(resultData201);
                    return result201;
                });
            } else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400: any = null;
                    let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException("Bad Request", status, _responseText, _headers, result400);
                });
            } else {
                return response.text().then((_responseText) => {
                    let resultdefault: any = null;
                    let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    resultdefault = ProblemDetails.fromJS(resultDatadefault);
                    return throwException("Error", status, _responseText, _headers, resultdefault);
                });
            }
        }

        /**
         * Deletes an existing Carrier given the specified Id.
         * @param id The Id of the Carrier to delete.
         * @return Success
         */
        v1DELETE2(id: number): Promise<void> {
            let url_ = this.baseUrl + "/Carrier/v1/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");

            let options_ = <RequestInit>{
                method: "DELETE",
                headers: {
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processV1DELETE2(_response);
            });
        }

        protected processV1DELETE2(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404: any = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException("Not Found", status, _responseText, _headers, result404);
                });
            } else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400: any = null;
                    let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException("Bad Request", status, _responseText, _headers, result400);
                });
            } else if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            } else {
                return response.text().then((_responseText) => {
                    let resultdefault: any = null;
                    let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    resultdefault = ProblemDetails.fromJS(resultDatadefault);
                    return throwException("Error", status, _responseText, _headers, resultdefault);
                });
            }
        }

        /**
         * Gets an existing Carrier given the specified Id.
         * @param id The Id to get Carrier for.
         * @param extend (optional) A list of keys on which to extend the Carrier, e.g. HourRegistrations, CarrierType.
         * @return Success
         */
        v1GET(id: number, extend: string[] | undefined): Promise<Carrier> {
            let url_ = this.baseUrl + "/Carrier/v1/{id}?";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            if (extend === null)
                throw new Error("The parameter 'extend' cannot be null.");
            else if (extend !== undefined)
                extend && extend.forEach(item => { url_ += "extend=" + encodeURIComponent("" + item) + "&"; });
            url_ = url_.replace(/[?&]$/, "");

            let options_ = <RequestInit>{
                method: "GET",
                headers: {
                    "Accept": "text/plain"
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processV1GET(_response);
            });
        }

        protected processV1GET(response: Response): Promise<Carrier> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404: any = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException("Not Found", status, _responseText, _headers, result404);
                });
            } else if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200: any = null;
                    let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = Carrier.fromJS(resultData200);
                    return result200;
                });
            } else {
                return response.text().then((_responseText) => {
                    let resultdefault: any = null;
                    let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    resultdefault = ProblemDetails.fromJS(resultDatadefault);
                    return throwException("Error", status, _responseText, _headers, resultdefault);
                });
            }
        }

        /**
         * Patches an existing Carrier given the specified Id.
         * @param id The Id of the Carrier to patch.
         * @param body (optional) The operations to perform on  CarrierCreate.
         * @return Success
         */
        v1PATCH2(id: number, body: JsonPatchOperation[] | undefined): Promise<void> {
            let url_ = this.baseUrl + "/Carrier/v1/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");

            const content_ = JSON.stringify(body);

            let options_ = <RequestInit>{
                body: content_,
                method: "PATCH",
                headers: {
                    "Content-Type": "application/json-patch+json",
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processV1PATCH2(_response);
            });
        }

        protected processV1PATCH2(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400: any = null;
                    let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException("Bad Request", status, _responseText, _headers, result400);
                });
            } else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404: any = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException("Not Found", status, _responseText, _headers, result404);
                });
            } else if (status === 204) {
                return response.text().then((_responseText) => {
                    return;
                });
            } else {
                return response.text().then((_responseText) => {
                    let resultdefault: any = null;
                    let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    resultdefault = ProblemDetails.fromJS(resultDatadefault);
                    return throwException("Error", status, _responseText, _headers, resultdefault);
                });
            }
        }

        /**
         * Replaces an existing Carrier given the specified Id.
         * @param id The Id of the Carrier to replace.
         * @param body (optional) The CarrierCreate to create a new Carrier from.
         * @return Success
         */
        v1PUT2(id: number, body: CarrierCreate | undefined): Promise<void> {
            let url_ = this.baseUrl + "/Carrier/v1/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");

            const content_ = JSON.stringify(body);

            let options_ = <RequestInit>{
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json-patch+json",
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processV1PUT2(_response);
            });
        }

        protected processV1PUT2(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                    return;
                });
            } else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404: any = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException("Not Found", status, _responseText, _headers, result404);
                });
            } else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400: any = null;
                    let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException("Bad Request", status, _responseText, _headers, result400);
                });
            } else {
                return response.text().then((_responseText) => {
                    let resultdefault: any = null;
                    let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    resultdefault = ProblemDetails.fromJS(resultDatadefault);
                    return throwException("Error", status, _responseText, _headers, resultdefault);
                });
            }
        }

        /**
         * Gets all existing Carrier.
         * @param extend (optional) A list of keys on which to extend the Carrier, e.g. HourRegistrations, CarrierType.
         * @param filter (optional) Query object used for filtering the result list. Supported operators are [EQ], [NEQ], [GT], [GTE], [LT], [LTE], [IN], [NIN], [LIKE], [BETWEEN] for value properties.
         * @return Success
         */
        v1All2(extend: string[] | undefined, filter: any | undefined): Promise<Carrier[]> {
            let url_ = this.baseUrl + "/Carrier/v1?";
            if (extend === null)
                throw new Error("The parameter 'extend' cannot be null.");
            else if (extend !== undefined)
                extend && extend.forEach(item => { url_ += "extend=" + encodeURIComponent("" + item) + "&"; });
            if (filter === null)
                throw new Error("The parameter 'filter' cannot be null.");
            else if (filter !== undefined)
                url_ += "filter=" + encodeURIComponent("" + filter) + "&";
            url_ = url_.replace(/[?&]$/, "");

            let options_ = <RequestInit>{
                method: "GET",
                headers: {
                    "Accept": "text/plain"
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processV1All2(_response);
            });
        }

        protected processV1All2(response: Response): Promise<Carrier[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404: any = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException("Not Found", status, _responseText, _headers, result404);
                });
            } else if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200: any = null;
                    let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200)
                            result200!.push(Carrier.fromJS(item));
                    }
                    else {
                        result200 = <any>null;
                    }
                    return result200;
                });
            } else {
                return response.text().then((_responseText) => {
                    let resultdefault: any = null;
                    let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    resultdefault = ProblemDetails.fromJS(resultDatadefault);
                    return throwException("Error", status, _responseText, _headers, resultdefault);
                });
            }
        }

        /**
         * Creates a new Carrier.
         * @param body (optional) The CarrierCreate to create a new Carrier from.
         * @return Success
         */
        v1POST2(body: CarrierCreate | undefined): Promise<Carrier> {
            let url_ = this.baseUrl + "/Carrier/v1";
            url_ = url_.replace(/[?&]$/, "");

            const content_ = JSON.stringify(body);

            let options_ = <RequestInit>{
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json-patch+json",
                    "Accept": "text/plain"
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processV1POST2(_response);
            });
        }

        protected processV1POST2(response: Response): Promise<Carrier> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 201) {
                return response.text().then((_responseText) => {
                    let result201: any = null;
                    let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result201 = Carrier.fromJS(resultData201);
                    return result201;
                });
            } else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400: any = null;
                    let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException("Bad Request", status, _responseText, _headers, result400);
                });
            } else {
                return response.text().then((_responseText) => {
                    let resultdefault: any = null;
                    let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    resultdefault = ProblemDetails.fromJS(resultDatadefault);
                    return throwException("Error", status, _responseText, _headers, resultdefault);
                });
            }
        }

        /**
         * Deletes an existing CarrierType given the specified Id.
         * @param id The Id of the CarrierType to delete.
         * @return Success
         */
        v1DELETE3(id: number): Promise<void> {
            let url_ = this.baseUrl + "/CarrierType/v1/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");

            let options_ = <RequestInit>{
                method: "DELETE",
                headers: {
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processV1DELETE3(_response);
            });
        }

        protected processV1DELETE3(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404: any = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException("Not Found", status, _responseText, _headers, result404);
                });
            } else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400: any = null;
                    let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException("Bad Request", status, _responseText, _headers, result400);
                });
            } else if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            } else {
                return response.text().then((_responseText) => {
                    let resultdefault: any = null;
                    let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    resultdefault = ProblemDetails.fromJS(resultDatadefault);
                    return throwException("Error", status, _responseText, _headers, resultdefault);
                });
            }
        }

        /**
         * Gets an existing CarrierType given the specified Id.
         * @param id The Id to get CarrierType for.
         * @param extend (optional) A list of keys on which to extend the CarrierType, e.g. Carriers.
         * @return Success
         */
        v1GET2(id: number, extend: string[] | undefined): Promise<CarrierType> {
            let url_ = this.baseUrl + "/CarrierType/v1/{id}?";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            if (extend === null)
                throw new Error("The parameter 'extend' cannot be null.");
            else if (extend !== undefined)
                extend && extend.forEach(item => { url_ += "extend=" + encodeURIComponent("" + item) + "&"; });
            url_ = url_.replace(/[?&]$/, "");

            let options_ = <RequestInit>{
                method: "GET",
                headers: {
                    "Accept": "text/plain"
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processV1GET2(_response);
            });
        }

        protected processV1GET2(response: Response): Promise<CarrierType> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404: any = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException("Not Found", status, _responseText, _headers, result404);
                });
            } else if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200: any = null;
                    let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = CarrierType.fromJS(resultData200);
                    return result200;
                });
            } else {
                return response.text().then((_responseText) => {
                    let resultdefault: any = null;
                    let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    resultdefault = ProblemDetails.fromJS(resultDatadefault);
                    return throwException("Error", status, _responseText, _headers, resultdefault);
                });
            }
        }

        /**
         * Patches an existing CarrierType given the specified Id.
         * @param id The Id of the CarrierType to patch.
         * @param body (optional) The operations to perform on CarrierTypeCreate.
         * @return Success
         */
        v1PATCH3(id: number, body: JsonPatchOperation[] | undefined): Promise<void> {
            let url_ = this.baseUrl + "/CarrierType/v1/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");

            const content_ = JSON.stringify(body);

            let options_ = <RequestInit>{
                body: content_,
                method: "PATCH",
                headers: {
                    "Content-Type": "application/json-patch+json",
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processV1PATCH3(_response);
            });
        }

        protected processV1PATCH3(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400: any = null;
                    let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException("Bad Request", status, _responseText, _headers, result400);
                });
            } else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404: any = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException("Not Found", status, _responseText, _headers, result404);
                });
            } else if (status === 204) {
                return response.text().then((_responseText) => {
                    return;
                });
            } else {
                return response.text().then((_responseText) => {
                    let resultdefault: any = null;
                    let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    resultdefault = ProblemDetails.fromJS(resultDatadefault);
                    return throwException("Error", status, _responseText, _headers, resultdefault);
                });
            }
        }

        /**
         * Replaces an existing CarrierType given the specified Id.
         * @param id The Id of the CarrierType to replace.
         * @param body (optional) The CarrierTypeCreate to create a new CarrierType from.
         * @return Success
         */
        v1PUT3(id: number, body: CarrierTypeCreate | undefined): Promise<void> {
            let url_ = this.baseUrl + "/CarrierType/v1/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");

            const content_ = JSON.stringify(body);

            let options_ = <RequestInit>{
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json-patch+json",
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processV1PUT3(_response);
            });
        }

        protected processV1PUT3(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                    return;
                });
            } else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404: any = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException("Not Found", status, _responseText, _headers, result404);
                });
            } else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400: any = null;
                    let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException("Bad Request", status, _responseText, _headers, result400);
                });
            } else {
                return response.text().then((_responseText) => {
                    let resultdefault: any = null;
                    let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    resultdefault = ProblemDetails.fromJS(resultDatadefault);
                    return throwException("Error", status, _responseText, _headers, resultdefault);
                });
            }
        }

        /**
         * Gets all existing CarrierType.
         * @param extend (optional) A list of keys on which to extend the CarrierType, e.g. Carriers.
         * @param filter (optional) Query object used for filtering the result list. Supported operators are [EQ], [NEQ], [GT], [GTE], [LT], [LTE], [IN], [NIN], [LIKE], [BETWEEN] for value properties.
         * @return Success
         */
        v1All3(extend: string[] | undefined, filter: any | undefined): Promise<CarrierType[]> {
            let url_ = this.baseUrl + "/CarrierType/v1?";
            if (extend === null)
                throw new Error("The parameter 'extend' cannot be null.");
            else if (extend !== undefined)
                extend && extend.forEach(item => { url_ += "extend=" + encodeURIComponent("" + item) + "&"; });
            if (filter === null)
                throw new Error("The parameter 'filter' cannot be null.");
            else if (filter !== undefined)
                url_ += "filter=" + encodeURIComponent("" + filter) + "&";
            url_ = url_.replace(/[?&]$/, "");

            let options_ = <RequestInit>{
                method: "GET",
                headers: {
                    "Accept": "text/plain"
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processV1All3(_response);
            });
        }

        protected processV1All3(response: Response): Promise<CarrierType[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404: any = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException("Not Found", status, _responseText, _headers, result404);
                });
            } else if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200: any = null;
                    let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200)
                            result200!.push(CarrierType.fromJS(item));
                    }
                    else {
                        result200 = <any>null;
                    }
                    return result200;
                });
            } else {
                return response.text().then((_responseText) => {
                    let resultdefault: any = null;
                    let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    resultdefault = ProblemDetails.fromJS(resultDatadefault);
                    return throwException("Error", status, _responseText, _headers, resultdefault);
                });
            }
        }

        /**
         * Creates a new CarrierType.
         * @param body (optional) The CarrierTypeCreate to create a new CarrierType of the type CT_Free from.
         * @return Success
         */
        v1POST3(body: CarrierTypeCreate | undefined): Promise<CarrierType> {
            let url_ = this.baseUrl + "/CarrierType/v1";
            url_ = url_.replace(/[?&]$/, "");

            const content_ = JSON.stringify(body);

            let options_ = <RequestInit>{
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json-patch+json",
                    "Accept": "text/plain"
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processV1POST3(_response);
            });
        }

        protected processV1POST3(response: Response): Promise<CarrierType> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 201) {
                return response.text().then((_responseText) => {
                    let result201: any = null;
                    let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result201 = CarrierType.fromJS(resultData201);
                    return result201;
                });
            } else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400: any = null;
                    let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException("Bad Request", status, _responseText, _headers, result400);
                });
            } else {
                return response.text().then((_responseText) => {
                    let resultdefault: any = null;
                    let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    resultdefault = ProblemDetails.fromJS(resultDatadefault);
                    return throwException("Error", status, _responseText, _headers, resultdefault);
                });
            }
        }

        /**
         * Deletes an existing Customer given the specified Id.
         * @param id The Id of the Customer to delete.
         * @return Success
         */
        v1DELETE4(id: number): Promise<void> {
            let url_ = this.baseUrl + "/Customer/v1/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");

            let options_ = <RequestInit>{
                method: "DELETE",
                headers: {
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processV1DELETE4(_response);
            });
        }

        protected processV1DELETE4(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404: any = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException("Not Found", status, _responseText, _headers, result404);
                });
            } else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400: any = null;
                    let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException("Bad Request", status, _responseText, _headers, result400);
                });
            } else if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            } else {
                return response.text().then((_responseText) => {
                    let resultdefault: any = null;
                    let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    resultdefault = ProblemDetails.fromJS(resultDatadefault);
                    return throwException("Error", status, _responseText, _headers, resultdefault);
                });
            }
        }

        /**
         * Gets an existing Customer given the specified Id.
         * @param id The Id to get Customer for.
         * @param extend (optional) A list of keys on which to extend the Customer, e.g. Address, ContactInfo, ContactPerson, HourRegistrations.
         * @return Success
         */
        v1GET3(id: number, extend: string[] | undefined): Promise<Customer> {
            let url_ = this.baseUrl + "/Customer/v1/{id}?";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            if (extend === null)
                throw new Error("The parameter 'extend' cannot be null.");
            else if (extend !== undefined)
                extend && extend.forEach(item => { url_ += "extend=" + encodeURIComponent("" + item) + "&"; });
            url_ = url_.replace(/[?&]$/, "");

            let options_ = <RequestInit>{
                method: "GET",
                headers: {
                    "Accept": "text/plain"
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processV1GET3(_response);
            });
        }

        protected processV1GET3(response: Response): Promise<Customer> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404: any = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException("Not Found", status, _responseText, _headers, result404);
                });
            } else if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200: any = null;
                    let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = Customer.fromJS(resultData200);
                    return result200;
                });
            } else {
                return response.text().then((_responseText) => {
                    let resultdefault: any = null;
                    let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    resultdefault = ProblemDetails.fromJS(resultDatadefault);
                    return throwException("Error", status, _responseText, _headers, resultdefault);
                });
            }
        }

        /**
         * Patches an existing Customer given the specified Id.
         * @param id The Id of the Customer to patch.
         * @param body (optional) The operations to perform on CustomerCreate.
         * @return Success
         */
        v1PATCH4(id: number, body: JsonPatchOperation[] | undefined): Promise<void> {
            let url_ = this.baseUrl + "/Customer/v1/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");

            const content_ = JSON.stringify(body);

            let options_ = <RequestInit>{
                body: content_,
                method: "PATCH",
                headers: {
                    "Content-Type": "application/json-patch+json",
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processV1PATCH4(_response);
            });
        }

        protected processV1PATCH4(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400: any = null;
                    let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException("Bad Request", status, _responseText, _headers, result400);
                });
            } else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404: any = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException("Not Found", status, _responseText, _headers, result404);
                });
            } else if (status === 204) {
                return response.text().then((_responseText) => {
                    return;
                });
            } else {
                return response.text().then((_responseText) => {
                    let resultdefault: any = null;
                    let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    resultdefault = ProblemDetails.fromJS(resultDatadefault);
                    return throwException("Error", status, _responseText, _headers, resultdefault);
                });
            }
        }

        /**
         * Replaces an existing Customer given the specified Id.
         * @param id The Id of the Customer to replace.
         * @param body (optional) The CustomerCreate to create a new Customer from.
         * @return Success
         */
        v1PUT4(id: number, body: CustomerCreate | undefined): Promise<void> {
            let url_ = this.baseUrl + "/Customer/v1/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");

            const content_ = JSON.stringify(body);

            let options_ = <RequestInit>{
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json-patch+json",
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processV1PUT4(_response);
            });
        }

        protected processV1PUT4(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                    return;
                });
            } else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404: any = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException("Not Found", status, _responseText, _headers, result404);
                });
            } else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400: any = null;
                    let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException("Bad Request", status, _responseText, _headers, result400);
                });
            } else {
                return response.text().then((_responseText) => {
                    let resultdefault: any = null;
                    let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    resultdefault = ProblemDetails.fromJS(resultDatadefault);
                    return throwException("Error", status, _responseText, _headers, resultdefault);
                });
            }
        }

        /**
         * Gets all existing Customer.
         * @param extend (optional) A list of keys on which to extend the Customer, e.g. Address, ContactInfo, ContactPerson, HourRegistrations.
         * @param filter (optional) Query object used for filtering the result list. Supported operators are [EQ], [NEQ], [GT], [GTE], [LT], [LTE], [IN], [NIN], [LIKE], [BETWEEN] for value properties.
         * @return Success
         */
        v1All4(extend: string[] | undefined, filter: any | undefined): Promise<Customer[]> {
            let url_ = this.baseUrl + "/Customer/v1?";
            if (extend === null)
                throw new Error("The parameter 'extend' cannot be null.");
            else if (extend !== undefined)
                extend && extend.forEach(item => { url_ += "extend=" + encodeURIComponent("" + item) + "&"; });
            if (filter === null)
                throw new Error("The parameter 'filter' cannot be null.");
            else if (filter !== undefined)
                url_ += "filter=" + encodeURIComponent("" + filter) + "&";
            url_ = url_.replace(/[?&]$/, "");

            let options_ = <RequestInit>{
                method: "GET",
                headers: {
                    "Accept": "text/plain"
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processV1All4(_response);
            });
        }

        protected processV1All4(response: Response): Promise<Customer[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404: any = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException("Not Found", status, _responseText, _headers, result404);
                });
            } else if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200: any = null;
                    let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200)
                            result200!.push(Customer.fromJS(item));
                    }
                    else {
                        result200 = <any>null;
                    }
                    return result200;
                });
            } else {
                return response.text().then((_responseText) => {
                    let resultdefault: any = null;
                    let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    resultdefault = ProblemDetails.fromJS(resultDatadefault);
                    return throwException("Error", status, _responseText, _headers, resultdefault);
                });
            }
        }

        /**
         * Creates a new Customer.
         * @param body (optional) The CustomerCreate to create a new Customer from.
         * @return Success
         */
        v1POST4(body: CustomerCreate | undefined): Promise<Customer> {
            let url_ = this.baseUrl + "/Customer/v1";
            url_ = url_.replace(/[?&]$/, "");

            const content_ = JSON.stringify(body);

            let options_ = <RequestInit>{
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json-patch+json",
                    "Accept": "text/plain"
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processV1POST4(_response);
            });
        }

        protected processV1POST4(response: Response): Promise<Customer> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 201) {
                return response.text().then((_responseText) => {
                    let result201: any = null;
                    let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result201 = Customer.fromJS(resultData201);
                    return result201;
                });
            } else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400: any = null;
                    let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException("Bad Request", status, _responseText, _headers, result400);
                });
            } else {
                return response.text().then((_responseText) => {
                    let resultdefault: any = null;
                    let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    resultdefault = ProblemDetails.fromJS(resultDatadefault);
                    return throwException("Error", status, _responseText, _headers, resultdefault);
                });
            }
        }

        /**
         * Deletes an existing HourRegistration given the specified Id.
         * @param id The Id of the HourRegistration to delete.
         * @return Success
         */
        v1DELETE5(id: number): Promise<void> {
            let url_ = this.baseUrl + "/HourRegistration/v1/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");

            let options_ = <RequestInit>{
                method: "DELETE",
                headers: {
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processV1DELETE5(_response);
            });
        }

        protected processV1DELETE5(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404: any = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException("Not Found", status, _responseText, _headers, result404);
                });
            } else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400: any = null;
                    let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException("Bad Request", status, _responseText, _headers, result400);
                });
            } else if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            } else {
                return response.text().then((_responseText) => {
                    let resultdefault: any = null;
                    let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    resultdefault = ProblemDetails.fromJS(resultDatadefault);
                    return throwException("Error", status, _responseText, _headers, resultdefault);
                });
            }
        }

        /**
         * Gets an existing HourRegistration given the specified Id.
         * @param id The Id to get HourRegistration for.
         * @param extend (optional) A list of keys on which to extend the HourRegistration, e.g. Article,Customer, Carriers.
         * @return Success
         */
        v1GET4(id: number, extend: string[] | undefined): Promise<HourRegistration> {
            let url_ = this.baseUrl + "/HourRegistration/v1/{id}?";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            if (extend === null)
                throw new Error("The parameter 'extend' cannot be null.");
            else if (extend !== undefined)
                extend && extend.forEach(item => { url_ += "extend=" + encodeURIComponent("" + item) + "&"; });
            url_ = url_.replace(/[?&]$/, "");

            let options_ = <RequestInit>{
                method: "GET",
                headers: {
                    "Accept": "text/plain"
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processV1GET4(_response);
            });
        }

        protected processV1GET4(response: Response): Promise<HourRegistration> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404: any = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException("Not Found", status, _responseText, _headers, result404);
                });
            } else if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200: any = null;
                    let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = HourRegistration.fromJS(resultData200);
                    return result200;
                });
            } else {
                return response.text().then((_responseText) => {
                    let resultdefault: any = null;
                    let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    resultdefault = ProblemDetails.fromJS(resultDatadefault);
                    return throwException("Error", status, _responseText, _headers, resultdefault);
                });
            }
        }

        /**
         * Patches an existing HourRegistration given the specified Id.
         * @param id The Id of the HourRegistration to patch.
         * @param body (optional) The operations to perform onHourRegistrationCreate.
         * @return Success
         */
        v1PATCH5(id: number, body: JsonPatchOperation[] | undefined): Promise<void> {
            let url_ = this.baseUrl + "/HourRegistration/v1/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");

            const content_ = JSON.stringify(body);

            let options_ = <RequestInit>{
                body: content_,
                method: "PATCH",
                headers: {
                    "Content-Type": "application/json-patch+json",
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processV1PATCH5(_response);
            });
        }

        protected processV1PATCH5(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400: any = null;
                    let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException("Bad Request", status, _responseText, _headers, result400);
                });
            } else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404: any = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException("Not Found", status, _responseText, _headers, result404);
                });
            } else if (status === 204) {
                return response.text().then((_responseText) => {
                    return;
                });
            } else {
                return response.text().then((_responseText) => {
                    let resultdefault: any = null;
                    let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    resultdefault = ProblemDetails.fromJS(resultDatadefault);
                    return throwException("Error", status, _responseText, _headers, resultdefault);
                });
            }
        }

        /**
         * Replaces an existing HourRegistration given the specified Id.
         * @param id The Id of the HourRegistration to replace.
         * @param body (optional) The HourRegistrationCreate to create a new HourRegistration from.
         * @return Success
         */
        v1PUT5(id: number, body: HourRegistrationCreate | undefined): Promise<void> {
            let url_ = this.baseUrl + "/HourRegistration/v1/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");

            const content_ = JSON.stringify(body);

            let options_ = <RequestInit>{
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json-patch+json",
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processV1PUT5(_response);
            });
        }

        protected processV1PUT5(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                    return;
                });
            } else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404: any = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException("Not Found", status, _responseText, _headers, result404);
                });
            } else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400: any = null;
                    let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException("Bad Request", status, _responseText, _headers, result400);
                });
            } else {
                return response.text().then((_responseText) => {
                    let resultdefault: any = null;
                    let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    resultdefault = ProblemDetails.fromJS(resultDatadefault);
                    return throwException("Error", status, _responseText, _headers, resultdefault);
                });
            }
        }

        /**
         * Gets all existing HourRegistration.
         * @param extend (optional) A list of keys on which to extend the HourRegistration, e.g. Article, Customer.
         * @param filter (optional) Query object used for filtering the result list. Supported operators are [EQ], [NEQ], [GT], [GTE], [LT], [LTE], [IN], [NIN], [LIKE], [BETWEEN] for value properties.
         * @return Success
         */
        v1All5(extend: string[] | undefined, filter: any | undefined): Promise<HourRegistration[]> {
            let url_ = this.baseUrl + "/HourRegistration/v1?";
            if (extend === null)
                throw new Error("The parameter 'extend' cannot be null.");
            else if (extend !== undefined)
                extend && extend.forEach(item => { url_ += "extend=" + encodeURIComponent("" + item) + "&"; });
            if (filter === null)
                throw new Error("The parameter 'filter' cannot be null.");
            else if (filter !== undefined)
                url_ += "filter=" + encodeURIComponent("" + filter) + "&";
            url_ = url_.replace(/[?&]$/, "");

            let options_ = <RequestInit>{
                method: "GET",
                headers: {
                    "Accept": "text/plain"
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processV1All5(_response);
            });
        }

        protected processV1All5(response: Response): Promise<HourRegistration[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404: any = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException("Not Found", status, _responseText, _headers, result404);
                });
            } else if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200: any = null;
                    let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200)
                            result200!.push(HourRegistration.fromJS(item));
                    }
                    else {
                        result200 = <any>null;
                    }
                    return result200;
                });
            } else {
                return response.text().then((_responseText) => {
                    let resultdefault: any = null;
                    let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    resultdefault = ProblemDetails.fromJS(resultDatadefault);
                    return throwException("Error", status, _responseText, _headers, resultdefault);
                });
            }
        }

        /**
         * Creates a new HourRegistration.
         * @param body (optional) The HourRegistrationCreate to create a new HourRegistration from.
         * @return Success
         */
        v1POST5(body: HourRegistrationCreate | undefined): Promise<HourRegistration> {
            let url_ = this.baseUrl + "/HourRegistration/v1";
            url_ = url_.replace(/[?&]$/, "");

            const content_ = JSON.stringify(body);

            let options_ = <RequestInit>{
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json-patch+json",
                    "Accept": "text/plain"
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processV1POST5(_response);
            });
        }

        protected processV1POST5(response: Response): Promise<HourRegistration> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 201) {
                return response.text().then((_responseText) => {
                    let result201: any = null;
                    let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result201 = HourRegistration.fromJS(resultData201);
                    return result201;
                });
            } else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400: any = null;
                    let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException("Bad Request", status, _responseText, _headers, result400);
                });
            } else {
                return response.text().then((_responseText) => {
                    let resultdefault: any = null;
                    let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    resultdefault = ProblemDetails.fromJS(resultDatadefault);
                    return throwException("Error", status, _responseText, _headers, resultdefault);
                });
            }
        }

        /**
         * Gets an existing HourRegistrationDocument given the specified Id.
         * @param id The Id to get HourRegistrationDocument for.
         * @param extend (optional) A list of keys on which to extend the Customer, e.g. Orders (not implemented).
         * @return Success
         */
        v1GET5(id: string, extend: string[] | undefined): Promise<HourRegistrationDocument> {
            let url_ = this.baseUrl + "/HourRegistrationDocument/v1/{id}?";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            if (extend === null)
                throw new Error("The parameter 'extend' cannot be null.");
            else if (extend !== undefined)
                extend && extend.forEach(item => { url_ += "extend=" + encodeURIComponent("" + item) + "&"; });
            url_ = url_.replace(/[?&]$/, "");

            let options_ = <RequestInit>{
                method: "GET",
                headers: {
                    "Accept": "text/plain"
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processV1GET5(_response);
            });
        }

        protected processV1GET5(response: Response): Promise<HourRegistrationDocument> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404: any = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException("Not Found", status, _responseText, _headers, result404);
                });
            } else if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200: any = null;
                    let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = HourRegistrationDocument.fromJS(resultData200);
                    return result200;
                });
            } else {
                return response.text().then((_responseText) => {
                    let resultdefault: any = null;
                    let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    resultdefault = ProblemDetails.fromJS(resultDatadefault);
                    return throwException("Error", status, _responseText, _headers, resultdefault);
                });
            }
        }

        /**
         * Creates a new HourRegistrationDocument.
         * @param body (optional) The HourRegistrationDocumentCreate to create a new HourRegistrationDocument from.
         * @return Success
         */
        v1POST6(body: HourRegistrationDocumentCreate | undefined): Promise<string> {
            let url_ = this.baseUrl + "/HourRegistrationDocument/v1";
            url_ = url_.replace(/[?&]$/, "");

            const content_ = JSON.stringify(body);

            let options_ = <RequestInit>{
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json-patch+json",
                    "Accept": "text/plain"
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processV1POST6(_response);
            });
        }

        protected processV1POST6(response: Response): Promise<string> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 201) {
                return response.text().then((_responseText) => {
                    let result201: any = null;
                    let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result201 = resultData201 !== undefined ? resultData201 : <any>null;
                    return result201;
                });
            } else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400: any = null;
                    let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException("Bad Request", status, _responseText, _headers, result400);
                });
            } else {
                return response.text().then((_responseText) => {
                    let resultdefault: any = null;
                    let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    resultdefault = ProblemDetails.fromJS(resultDatadefault);
                    return throwException("Error", status, _responseText, _headers, resultdefault);
                });
            }
        }

        /**
         * Deletes an existing Project given the specified Id.
         * @param id The Id of the Project to delete.
         * @return Success
         */
        v1DELETE6(id: number): Promise<void> {
            let url_ = this.baseUrl + "/Project/v1/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");

            let options_ = <RequestInit>{
                method: "DELETE",
                headers: {
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processV1DELETE6(_response);
            });
        }

        protected processV1DELETE6(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404: any = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException("Not Found", status, _responseText, _headers, result404);
                });
            } else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400: any = null;
                    let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException("Bad Request", status, _responseText, _headers, result400);
                });
            } else if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            } else {
                return response.text().then((_responseText) => {
                    let resultdefault: any = null;
                    let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    resultdefault = ProblemDetails.fromJS(resultDatadefault);
                    return throwException("Error", status, _responseText, _headers, resultdefault);
                });
            }
        }

        /**
         * Gets an existing Project given the specified Id.
         * @param id The Id to get Project for.
         * @param extend (optional) A list of keys on which to extend the Project.
         * @return Success
         */
        v1GET6(id: number, extend: string[] | undefined): Promise<Project> {
            let url_ = this.baseUrl + "/Project/v1/{id}?";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            if (extend === null)
                throw new Error("The parameter 'extend' cannot be null.");
            else if (extend !== undefined)
                extend && extend.forEach(item => { url_ += "extend=" + encodeURIComponent("" + item) + "&"; });
            url_ = url_.replace(/[?&]$/, "");

            let options_ = <RequestInit>{
                method: "GET",
                headers: {
                    "Accept": "text/plain"
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processV1GET6(_response);
            });
        }

        protected processV1GET6(response: Response): Promise<Project> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404: any = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException("Not Found", status, _responseText, _headers, result404);
                });
            } else if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200: any = null;
                    let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = Project.fromJS(resultData200);
                    return result200;
                });
            } else {
                return response.text().then((_responseText) => {
                    let resultdefault: any = null;
                    let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    resultdefault = ProblemDetails.fromJS(resultDatadefault);
                    return throwException("Error", status, _responseText, _headers, resultdefault);
                });
            }
        }

        /**
         * Patches an existing Project given the specified Id.
         * @param id The Id of the Project to patch.
         * @param body (optional) The operations to perform onProjectCreate.
         * @return Success
         */
        v1PATCH6(id: number, body: JsonPatchOperation[] | undefined): Promise<void> {
            let url_ = this.baseUrl + "/Project/v1/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");

            const content_ = JSON.stringify(body);

            let options_ = <RequestInit>{
                body: content_,
                method: "PATCH",
                headers: {
                    "Content-Type": "application/json-patch+json",
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processV1PATCH6(_response);
            });
        }

        protected processV1PATCH6(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400: any = null;
                    let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException("Bad Request", status, _responseText, _headers, result400);
                });
            } else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404: any = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException("Not Found", status, _responseText, _headers, result404);
                });
            } else if (status === 204) {
                return response.text().then((_responseText) => {
                    return;
                });
            } else {
                return response.text().then((_responseText) => {
                    let resultdefault: any = null;
                    let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    resultdefault = ProblemDetails.fromJS(resultDatadefault);
                    return throwException("Error", status, _responseText, _headers, resultdefault);
                });
            }
        }

        /**
         * Replaces an existing Project given the specified Id.
         * @param id The Id of the Project to replace.
         * @param body (optional) The ProjectCreate to create a new Project from.
         * @return Success
         */
        v1PUT6(id: number, body: ProjectCreate | undefined): Promise<void> {
            let url_ = this.baseUrl + "/Project/v1/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");

            const content_ = JSON.stringify(body);

            let options_ = <RequestInit>{
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json-patch+json",
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processV1PUT6(_response);
            });
        }

        protected processV1PUT6(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                    return;
                });
            } else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404: any = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException("Not Found", status, _responseText, _headers, result404);
                });
            } else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400: any = null;
                    let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException("Bad Request", status, _responseText, _headers, result400);
                });
            } else {
                return response.text().then((_responseText) => {
                    let resultdefault: any = null;
                    let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    resultdefault = ProblemDetails.fromJS(resultDatadefault);
                    return throwException("Error", status, _responseText, _headers, resultdefault);
                });
            }
        }

        /**
         * Gets all existing Project.
         * @param extend (optional) A list of keys on which to extend the Project.
         * @param filter (optional) Query object used for filtering the result list. Supported operators are [EQ], [NEQ], [GT], [GTE], [LT], [LTE], [IN], [NIN], [LIKE], [BETWEEN] for value properties.
         * @return Success
         */
        v1All6(extend: string[] | undefined, filter: any | undefined): Promise<Project[]> {
            let url_ = this.baseUrl + "/Project/v1?";
            if (extend === null)
                throw new Error("The parameter 'extend' cannot be null.");
            else if (extend !== undefined)
                extend && extend.forEach(item => { url_ += "extend=" + encodeURIComponent("" + item) + "&"; });
            if (filter === null)
                throw new Error("The parameter 'filter' cannot be null.");
            else if (filter !== undefined)
                url_ += "filter=" + encodeURIComponent("" + filter) + "&";
            url_ = url_.replace(/[?&]$/, "");

            let options_ = <RequestInit>{
                method: "GET",
                headers: {
                    "Accept": "text/plain"
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processV1All6(_response);
            });
        }

        protected processV1All6(response: Response): Promise<Project[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404: any = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException("Not Found", status, _responseText, _headers, result404);
                });
            } else if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200: any = null;
                    let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200)
                            result200!.push(Project.fromJS(item));
                    }
                    else {
                        result200 = <any>null;
                    }
                    return result200;
                });
            } else {
                return response.text().then((_responseText) => {
                    let resultdefault: any = null;
                    let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    resultdefault = ProblemDetails.fromJS(resultDatadefault);
                    return throwException("Error", status, _responseText, _headers, resultdefault);
                });
            }
        }

        /**
         * Creates a new Project.
         * @param body (optional) The ProjectCreate to create a new Project from.
         * @return Success
         */
        v1POST7(body: ProjectCreate | undefined): Promise<Project> {
            let url_ = this.baseUrl + "/Project/v1";
            url_ = url_.replace(/[?&]$/, "");

            const content_ = JSON.stringify(body);

            let options_ = <RequestInit>{
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json-patch+json",
                    "Accept": "text/plain"
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processV1POST7(_response);
            });
        }

        protected processV1POST7(response: Response): Promise<Project> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 201) {
                return response.text().then((_responseText) => {
                    let result201: any = null;
                    let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result201 = Project.fromJS(resultData201);
                    return result201;
                });
            } else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400: any = null;
                    let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException("Bad Request", status, _responseText, _headers, result400);
                });
            } else {
                return response.text().then((_responseText) => {
                    let resultdefault: any = null;
                    let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    resultdefault = ProblemDetails.fromJS(resultDatadefault);
                    return throwException("Error", status, _responseText, _headers, resultdefault);
                });
            }
        }
    }

    export class Article implements IArticle {
        readonly id!: number;
        articleNumber!: string;
        name!: string;
        articleType!: ArticleType;
        salesPrice?: number;
        invoiceStatus?: InvoiceStatus;
        metadata?: ArticleMetadata;
        unit?: string | undefined;
        readonly hourRegistrations?: HourRegistration[] | undefined;
        /** false if soft deleted */
        readonly show?: boolean;
        readonly rowversion?: number;

        constructor(data?: IArticle) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }

        init(_data?: any) {
            if (_data) {
                (<any>this).id = _data["id"];
                this.articleNumber = _data["articleNumber"];
                this.name = _data["name"];
                this.articleType = _data["articleType"];
                this.salesPrice = _data["salesPrice"];
                this.invoiceStatus = _data["invoiceStatus"];
                this.metadata = _data["metadata"] ? ArticleMetadata.fromJS(_data["metadata"]) : <any>undefined;
                this.unit = _data["unit"];
                if (Array.isArray(_data["hourRegistrations"])) {
                    (<any>this).hourRegistrations = [] as any;
                    for (let item of _data["hourRegistrations"])
                        (<any>this).hourRegistrations!.push(HourRegistration.fromJS(item));
                }
                (<any>this).show = _data["show"];
                (<any>this).rowversion = _data["rowversion"];
            }
        }

        static fromJS(data: any): Article {
            data = typeof data === 'object' ? data : {};
            let result = new Article();
            result.init(data);
            return result;
        }

        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["id"] = this.id;
            data["articleNumber"] = this.articleNumber;
            data["name"] = this.name;
            data["articleType"] = this.articleType;
            data["salesPrice"] = this.salesPrice;
            data["invoiceStatus"] = this.invoiceStatus;
            data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
            data["unit"] = this.unit;
            if (Array.isArray(this.hourRegistrations)) {
                data["hourRegistrations"] = [];
                for (let item of this.hourRegistrations)
                    data["hourRegistrations"].push(item.toJSON());
            }
            data["show"] = this.show;
            data["rowversion"] = this.rowversion;
            return data;
        }
    }

    export interface IArticle {
        id: number;
        articleNumber: string;
        name: string;
        articleType: ArticleType;
        salesPrice?: number;
        invoiceStatus?: InvoiceStatus;
        metadata?: ArticleMetadata;
        unit?: string | undefined;
        hourRegistrations?: HourRegistration[] | undefined;
        /** false if soft deleted */
        show?: boolean;
        rowversion?: number;
    }

    export class ArticleCreate implements IArticleCreate {
        articleNumber!: string;
        name!: string;
        articleType!: ArticleType;
        salesPrice?: number;
        metadata?: ArticleMetadata;
        unit?: string | undefined;

        constructor(data?: IArticleCreate) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }

        init(_data?: any) {
            if (_data) {
                this.articleNumber = _data["articleNumber"];
                this.name = _data["name"];
                this.articleType = _data["articleType"];
                this.salesPrice = _data["salesPrice"];
                this.metadata = _data["metadata"] ? ArticleMetadata.fromJS(_data["metadata"]) : <any>undefined;
                this.unit = _data["unit"];
            }
        }

        static fromJS(data: any): ArticleCreate {
            data = typeof data === 'object' ? data : {};
            let result = new ArticleCreate();
            result.init(data);
            return result;
        }

        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["articleNumber"] = this.articleNumber;
            data["name"] = this.name;
            data["articleType"] = this.articleType;
            data["salesPrice"] = this.salesPrice;
            data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
            data["unit"] = this.unit;
            return data;
        }
    }

    export interface IArticleCreate {
        articleNumber: string;
        name: string;
        articleType: ArticleType;
        salesPrice?: number;
        metadata?: ArticleMetadata;
        unit?: string | undefined;
    }

    export class ArticleMetadata implements IArticleMetadata {
        description?: string | undefined;
        ean?: string | undefined;
        netWeight?: number | undefined;
        grossWeight?: number | undefined;
        netVolume?: number | undefined;
        grossVolume?: number | undefined;
        readonly articleId?: number;

        constructor(data?: IArticleMetadata) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }

        init(_data?: any) {
            if (_data) {
                this.description = _data["description"];
                this.ean = _data["ean"];
                this.netWeight = _data["netWeight"];
                this.grossWeight = _data["grossWeight"];
                this.netVolume = _data["netVolume"];
                this.grossVolume = _data["grossVolume"];
                (<any>this).articleId = _data["articleId"];
            }
        }

        static fromJS(data: any): ArticleMetadata {
            data = typeof data === 'object' ? data : {};
            let result = new ArticleMetadata();
            result.init(data);
            return result;
        }

        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["description"] = this.description;
            data["ean"] = this.ean;
            data["netWeight"] = this.netWeight;
            data["grossWeight"] = this.grossWeight;
            data["netVolume"] = this.netVolume;
            data["grossVolume"] = this.grossVolume;
            data["articleId"] = this.articleId;
            return data;
        }
    }

    export interface IArticleMetadata {
        description?: string | undefined;
        ean?: string | undefined;
        netWeight?: number | undefined;
        grossWeight?: number | undefined;
        netVolume?: number | undefined;
        grossVolume?: number | undefined;
        articleId?: number;
    }

    export enum ArticleType {
        Normal = "normal",
        Amount = "amount",
        Hour = "hour",
    }

    export enum AttestationStatus {
        NoAttestation = "noAttestation",
        ToAttest = "toAttest",
        Attested = "attested",
        Rejected = "rejected",
    }

    export class Carrier implements ICarrier {
        readonly id!: number;
        name!: string;
        key?: string | undefined;
        readonly carrierTypeId!: number;
        carrierType?: CarrierType;
        employee?: Employee;
        project?: Project;
        department?: Department;
        wageType?: WageType;
        readonly hourRegistrations?: HourRegistrationCarrier[] | undefined;
        /** false if soft deleted */
        readonly show?: boolean;
        readonly rowversion?: number;

        constructor(data?: ICarrier) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }

        init(_data?: any) {
            if (_data) {
                (<any>this).id = _data["id"];
                this.name = _data["name"];
                this.key = _data["key"];
                (<any>this).carrierTypeId = _data["carrierTypeId"];
                this.carrierType = _data["carrierType"] ? CarrierType.fromJS(_data["carrierType"]) : <any>undefined;
                this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
                this.project = _data["project"] ? Project.fromJS(_data["project"]) : <any>undefined;
                this.department = _data["department"] ? Department.fromJS(_data["department"]) : <any>undefined;
                this.wageType = _data["wageType"] ? WageType.fromJS(_data["wageType"]) : <any>undefined;
                if (Array.isArray(_data["hourRegistrations"])) {
                    (<any>this).hourRegistrations = [] as any;
                    for (let item of _data["hourRegistrations"])
                        (<any>this).hourRegistrations!.push(HourRegistrationCarrier.fromJS(item));
                }
                (<any>this).show = _data["show"];
                (<any>this).rowversion = _data["rowversion"];
            }
        }

        static fromJS(data: any): Carrier {
            data = typeof data === 'object' ? data : {};
            let result = new Carrier();
            result.init(data);
            return result;
        }

        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["id"] = this.id;
            data["name"] = this.name;
            data["key"] = this.key;
            data["carrierTypeId"] = this.carrierTypeId;
            data["carrierType"] = this.carrierType ? this.carrierType.toJSON() : <any>undefined;
            data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
            data["project"] = this.project ? this.project.toJSON() : <any>undefined;
            data["department"] = this.department ? this.department.toJSON() : <any>undefined;
            data["wageType"] = this.wageType ? this.wageType.toJSON() : <any>undefined;
            if (Array.isArray(this.hourRegistrations)) {
                data["hourRegistrations"] = [];
                for (let item of this.hourRegistrations)
                    data["hourRegistrations"].push(item.toJSON());
            }
            data["show"] = this.show;
            data["rowversion"] = this.rowversion;
            return data;
        }
    }

    export interface ICarrier {
        id: number;
        name: string;
        key?: string | undefined;
        carrierTypeId: number;
        carrierType?: CarrierType;
        employee?: Employee;
        project?: Project;
        department?: Department;
        wageType?: WageType;
        hourRegistrations?: HourRegistrationCarrier[] | undefined;
        /** false if soft deleted */
        show?: boolean;
        rowversion?: number;
    }

    export class CarrierCreate implements ICarrierCreate {
        name!: string;
        key!: string;
        carrierTypeId!: number;

        constructor(data?: ICarrierCreate) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }

        init(_data?: any) {
            if (_data) {
                this.name = _data["name"];
                this.key = _data["key"];
                this.carrierTypeId = _data["carrierTypeId"];
            }
        }

        static fromJS(data: any): CarrierCreate {
            data = typeof data === 'object' ? data : {};
            let result = new CarrierCreate();
            result.init(data);
            return result;
        }

        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["name"] = this.name;
            data["key"] = this.key;
            data["carrierTypeId"] = this.carrierTypeId;
            return data;
        }
    }

    export interface ICarrierCreate {
        name: string;
        key: string;
        carrierTypeId: number;
    }

    export class CarrierType implements ICarrierType {
        readonly id!: number;
        carrierTypeKind!: CarrierTypeKind;
        name!: string;
        usedInAccounting!: boolean;
        usedInHour!: boolean;
        usedInInvoice!: boolean;
        usedInLedger!: boolean;
        usedInSalary!: boolean;
        readonly carriers?: Carrier[] | undefined;
        readonly rowversion?: number;

        constructor(data?: ICarrierType) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }

        init(_data?: any) {
            if (_data) {
                (<any>this).id = _data["id"];
                this.carrierTypeKind = _data["carrierTypeKind"];
                this.name = _data["name"];
                this.usedInAccounting = _data["usedInAccounting"];
                this.usedInHour = _data["usedInHour"];
                this.usedInInvoice = _data["usedInInvoice"];
                this.usedInLedger = _data["usedInLedger"];
                this.usedInSalary = _data["usedInSalary"];
                if (Array.isArray(_data["carriers"])) {
                    (<any>this).carriers = [] as any;
                    for (let item of _data["carriers"])
                        (<any>this).carriers!.push(Carrier.fromJS(item));
                }
                (<any>this).rowversion = _data["rowversion"];
            }
        }

        static fromJS(data: any): CarrierType {
            data = typeof data === 'object' ? data : {};
            let result = new CarrierType();
            result.init(data);
            return result;
        }

        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["id"] = this.id;
            data["carrierTypeKind"] = this.carrierTypeKind;
            data["name"] = this.name;
            data["usedInAccounting"] = this.usedInAccounting;
            data["usedInHour"] = this.usedInHour;
            data["usedInInvoice"] = this.usedInInvoice;
            data["usedInLedger"] = this.usedInLedger;
            data["usedInSalary"] = this.usedInSalary;
            if (Array.isArray(this.carriers)) {
                data["carriers"] = [];
                for (let item of this.carriers)
                    data["carriers"].push(item.toJSON());
            }
            data["rowversion"] = this.rowversion;
            return data;
        }
    }

    export interface ICarrierType {
        id: number;
        carrierTypeKind: CarrierTypeKind;
        name: string;
        usedInAccounting: boolean;
        usedInHour: boolean;
        usedInInvoice: boolean;
        usedInLedger: boolean;
        usedInSalary: boolean;
        carriers?: Carrier[] | undefined;
        rowversion?: number;
    }

    export class CarrierTypeCreate implements ICarrierTypeCreate {
        name!: string;
        usedInAccounting!: boolean;
        usedInHour!: boolean;
        usedInInvoice!: boolean;
        usedInLedger!: boolean;
        usedInSalary!: boolean;

        constructor(data?: ICarrierTypeCreate) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }

        init(_data?: any) {
            if (_data) {
                this.name = _data["name"];
                this.usedInAccounting = _data["usedInAccounting"];
                this.usedInHour = _data["usedInHour"];
                this.usedInInvoice = _data["usedInInvoice"];
                this.usedInLedger = _data["usedInLedger"];
                this.usedInSalary = _data["usedInSalary"];
            }
        }

        static fromJS(data: any): CarrierTypeCreate {
            data = typeof data === 'object' ? data : {};
            let result = new CarrierTypeCreate();
            result.init(data);
            return result;
        }

        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["name"] = this.name;
            data["usedInAccounting"] = this.usedInAccounting;
            data["usedInHour"] = this.usedInHour;
            data["usedInInvoice"] = this.usedInInvoice;
            data["usedInLedger"] = this.usedInLedger;
            data["usedInSalary"] = this.usedInSalary;
            return data;
        }
    }

    export interface ICarrierTypeCreate {
        name: string;
        usedInAccounting: boolean;
        usedInHour: boolean;
        usedInInvoice: boolean;
        usedInLedger: boolean;
        usedInSalary: boolean;
    }

    export enum CarrierTypeKind {
        Free = "free",
        Project = "project",
        Production = "production",
        Employee = "employee",
        Department = "department",
        Task = "task",
        Activity = "activity",
        Year = "year",
        Product = "product",
        Trade = "trade",
        Asset = "asset",
        CostType = "costType",
        WorkType = "workType",
        Contract = "contract",
        RealEstate = "realEstate",
        Person = "person",
        Issuer = "issuer",
        Team = "team",
        Product2 = "product2",
        Detail = "detail",
        Quality = "quality",
        AdditionalTrait = "additionalTrait",
        Organic = "organic",
        ForestInfo = "forestInfo",
        Wagetype = "wagetype",
        WorkplaceLocation = "workplaceLocation",
    }

    export class Contact implements IContact {
        name!: string;
        phone1?: string | undefined;
        phone2?: string | undefined;
        mobile?: string | undefined;
        email?: string | undefined;

        constructor(data?: IContact) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }

        init(_data?: any) {
            if (_data) {
                this.name = _data["name"];
                this.phone1 = _data["phone1"];
                this.phone2 = _data["phone2"];
                this.mobile = _data["mobile"];
                this.email = _data["email"];
            }
        }

        static fromJS(data: any): Contact {
            data = typeof data === 'object' ? data : {};
            let result = new Contact();
            result.init(data);
            return result;
        }

        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["name"] = this.name;
            data["phone1"] = this.phone1;
            data["phone2"] = this.phone2;
            data["mobile"] = this.mobile;
            data["email"] = this.email;
            return data;
        }
    }

    export interface IContact {
        name: string;
        phone1?: string | undefined;
        phone2?: string | undefined;
        mobile?: string | undefined;
        email?: string | undefined;
    }

    export class ContactPerson implements IContactPerson {
        name!: string;
        phone1?: string | undefined;
        phone2?: string | undefined;
        mobile?: string | undefined;
        email?: string | undefined;

        constructor(data?: IContactPerson) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }

        init(_data?: any) {
            if (_data) {
                this.name = _data["name"];
                this.phone1 = _data["phone1"];
                this.phone2 = _data["phone2"];
                this.mobile = _data["mobile"];
                this.email = _data["email"];
            }
        }

        static fromJS(data: any): ContactPerson {
            data = typeof data === 'object' ? data : {};
            let result = new ContactPerson();
            result.init(data);
            return result;
        }

        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["name"] = this.name;
            data["phone1"] = this.phone1;
            data["phone2"] = this.phone2;
            data["mobile"] = this.mobile;
            data["email"] = this.email;
            return data;
        }
    }

    export interface IContactPerson {
        name: string;
        phone1?: string | undefined;
        phone2?: string | undefined;
        mobile?: string | undefined;
        email?: string | undefined;
    }

    export class Customer implements ICustomer {
        readonly id!: number;
        /** Used for duplicate check */
        externalId!: string;
        readonly customerNumber!: string;
        vatNumber?: string | undefined;
        bankAccountNumber?: string | undefined;
        invoiceEmail?: string | undefined;
        hourAttestationMobile?: string | undefined;
        /** false if soft deleted */
        readonly show?: boolean;
        address!: StreetAddress;
        contactInfo!: Contact;
        contactPerson?: ContactPerson;
        readonly hourRegistrations?: HourRegistration[] | undefined;
        readonly rowversion?: number;

        constructor(data?: ICustomer) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
            if (!data) {
                this.address = new StreetAddress();
                this.contactInfo = new Contact();
            }
        }

        init(_data?: any) {
            if (_data) {
                (<any>this).id = _data["id"];
                this.externalId = _data["externalId"];
                (<any>this).customerNumber = _data["customerNumber"];
                this.vatNumber = _data["vatNumber"];
                this.bankAccountNumber = _data["bankAccountNumber"];
                this.invoiceEmail = _data["invoiceEmail"];
                this.hourAttestationMobile = _data["hourAttestationMobile"];
                (<any>this).show = _data["show"];
                this.address = _data["address"] ? StreetAddress.fromJS(_data["address"]) : new StreetAddress();
                this.contactInfo = _data["contactInfo"] ? Contact.fromJS(_data["contactInfo"]) : new Contact();
                this.contactPerson = _data["contactPerson"] ? ContactPerson.fromJS(_data["contactPerson"]) : <any>undefined;
                if (Array.isArray(_data["hourRegistrations"])) {
                    (<any>this).hourRegistrations = [] as any;
                    for (let item of _data["hourRegistrations"])
                        (<any>this).hourRegistrations!.push(HourRegistration.fromJS(item));
                }
                (<any>this).rowversion = _data["rowversion"];
            }
        }

        static fromJS(data: any): Customer {
            data = typeof data === 'object' ? data : {};
            let result = new Customer();
            result.init(data);
            return result;
        }

        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["id"] = this.id;
            data["externalId"] = this.externalId;
            data["customerNumber"] = this.customerNumber;
            data["vatNumber"] = this.vatNumber;
            data["bankAccountNumber"] = this.bankAccountNumber;
            data["invoiceEmail"] = this.invoiceEmail;
            data["hourAttestationMobile"] = this.hourAttestationMobile;
            data["show"] = this.show;
            data["address"] = this.address ? this.address.toJSON() : <any>undefined;
            data["contactInfo"] = this.contactInfo ? this.contactInfo.toJSON() : <any>undefined;
            data["contactPerson"] = this.contactPerson ? this.contactPerson.toJSON() : <any>undefined;
            if (Array.isArray(this.hourRegistrations)) {
                data["hourRegistrations"] = [];
                for (let item of this.hourRegistrations)
                    data["hourRegistrations"].push(item.toJSON());
            }
            data["rowversion"] = this.rowversion;
            return data;
        }
    }

    export interface ICustomer {
        id: number;
        /** Used for duplicate check */
        externalId: string;
        customerNumber: string;
        vatNumber?: string | undefined;
        bankAccountNumber?: string | undefined;
        invoiceEmail?: string | undefined;
        hourAttestationMobile?: string | undefined;
        /** false if soft deleted */
        show?: boolean;
        address: StreetAddress;
        contactInfo: Contact;
        contactPerson?: ContactPerson;
        hourRegistrations?: HourRegistration[] | undefined;
        rowversion?: number;
    }

    export class CustomerCreate implements ICustomerCreate {
        externalId!: string;
        vatNumber?: string | undefined;
        bankAccountNumber?: string | undefined;
        invoiceEmail?: string | undefined;
        hourAttestationMobile?: string | undefined;
        address!: StreetAddress;
        contactInfo!: Contact;
        contactPerson?: ContactPerson;

        constructor(data?: ICustomerCreate) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
            if (!data) {
                this.address = new StreetAddress();
                this.contactInfo = new Contact();
            }
        }

        init(_data?: any) {
            if (_data) {
                this.externalId = _data["externalId"];
                this.vatNumber = _data["vatNumber"];
                this.bankAccountNumber = _data["bankAccountNumber"];
                this.invoiceEmail = _data["invoiceEmail"];
                this.hourAttestationMobile = _data["hourAttestationMobile"];
                this.address = _data["address"] ? StreetAddress.fromJS(_data["address"]) : new StreetAddress();
                this.contactInfo = _data["contactInfo"] ? Contact.fromJS(_data["contactInfo"]) : new Contact();
                this.contactPerson = _data["contactPerson"] ? ContactPerson.fromJS(_data["contactPerson"]) : <any>undefined;
            }
        }

        static fromJS(data: any): CustomerCreate {
            data = typeof data === 'object' ? data : {};
            let result = new CustomerCreate();
            result.init(data);
            return result;
        }

        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["externalId"] = this.externalId;
            data["vatNumber"] = this.vatNumber;
            data["bankAccountNumber"] = this.bankAccountNumber;
            data["invoiceEmail"] = this.invoiceEmail;
            data["hourAttestationMobile"] = this.hourAttestationMobile;
            data["address"] = this.address ? this.address.toJSON() : <any>undefined;
            data["contactInfo"] = this.contactInfo ? this.contactInfo.toJSON() : <any>undefined;
            data["contactPerson"] = this.contactPerson ? this.contactPerson.toJSON() : <any>undefined;
            return data;
        }
    }

    export interface ICustomerCreate {
        externalId: string;
        vatNumber?: string | undefined;
        bankAccountNumber?: string | undefined;
        invoiceEmail?: string | undefined;
        hourAttestationMobile?: string | undefined;
        address: StreetAddress;
        contactInfo: Contact;
        contactPerson?: ContactPerson;
    }

    export class Department implements IDepartment {
        id?: number;
        address1?: string | undefined;
        address2?: string | undefined;
        organizationNumber?: string | undefined;
        cadastralNumber?: string | undefined;
        rowversion?: number;

        constructor(data?: IDepartment) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }

        init(_data?: any) {
            if (_data) {
                this.id = _data["id"];
                this.address1 = _data["address1"];
                this.address2 = _data["address2"];
                this.organizationNumber = _data["organizationNumber"];
                this.cadastralNumber = _data["cadastralNumber"];
                this.rowversion = _data["rowversion"];
            }
        }

        static fromJS(data: any): Department {
            data = typeof data === 'object' ? data : {};
            let result = new Department();
            result.init(data);
            return result;
        }

        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["id"] = this.id;
            data["address1"] = this.address1;
            data["address2"] = this.address2;
            data["organizationNumber"] = this.organizationNumber;
            data["cadastralNumber"] = this.cadastralNumber;
            data["rowversion"] = this.rowversion;
            return data;
        }
    }

    export interface IDepartment {
        id?: number;
        address1?: string | undefined;
        address2?: string | undefined;
        organizationNumber?: string | undefined;
        cadastralNumber?: string | undefined;
        rowversion?: number;
    }

    export class Employee implements IEmployee {
        id?: number;
        name?: string | undefined;
        address1?: string | undefined;
        address2?: string | undefined;
        email?: string | undefined;
        phonePrivate?: string | undefined;
        phoneMobile?: string | undefined;
        rowversion?: number;

        constructor(data?: IEmployee) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }

        init(_data?: any) {
            if (_data) {
                this.id = _data["id"];
                this.name = _data["name"];
                this.address1 = _data["address1"];
                this.address2 = _data["address2"];
                this.email = _data["email"];
                this.phonePrivate = _data["phonePrivate"];
                this.phoneMobile = _data["phoneMobile"];
                this.rowversion = _data["rowversion"];
            }
        }

        static fromJS(data: any): Employee {
            data = typeof data === 'object' ? data : {};
            let result = new Employee();
            result.init(data);
            return result;
        }

        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["id"] = this.id;
            data["name"] = this.name;
            data["address1"] = this.address1;
            data["address2"] = this.address2;
            data["email"] = this.email;
            data["phonePrivate"] = this.phonePrivate;
            data["phoneMobile"] = this.phoneMobile;
            data["rowversion"] = this.rowversion;
            return data;
        }
    }

    export interface IEmployee {
        id?: number;
        name?: string | undefined;
        address1?: string | undefined;
        address2?: string | undefined;
        email?: string | undefined;
        phonePrivate?: string | undefined;
        phoneMobile?: string | undefined;
        rowversion?: number;
    }

    export class HourRegistration implements IHourRegistration {
        readonly id!: number;
        /** Your reference */
        externalId?: string | undefined;
        /** The reference to the master hourRegistration in a group */
        masterRefId?: number | undefined;
        hourDate!: Date;
        hourCount?: number | undefined;
        hourPrice?: number | undefined;
        hoursInvoiced?: number | undefined;
        totalPrice?: number | undefined;
        description?: string | undefined;
        attestationStatus!: AttestationStatus;
        invoiceStatus!: InvoiceStatus;
        salaryStatus!: SalaryStatus;
        readonly articleId?: number | undefined;
        article?: Article;
        carriers?: HourRegistrationCarrier[] | undefined;
        readonly customerId?: number | undefined;
        customer?: Customer;
        documentationIds?: string[] | undefined;
        readonly rowversion?: number;

        constructor(data?: IHourRegistration) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }

        init(_data?: any) {
            if (_data) {
                (<any>this).id = _data["id"];
                this.externalId = _data["externalId"];
                this.masterRefId = _data["masterRefId"];
                this.hourDate = _data["hourDate"] ? new Date(_data["hourDate"].toString()) : <any>undefined;
                this.hourCount = _data["hourCount"];
                this.hourPrice = _data["hourPrice"];
                this.hoursInvoiced = _data["hoursInvoiced"];
                this.totalPrice = _data["totalPrice"];
                this.description = _data["description"];
                this.attestationStatus = _data["attestationStatus"];
                this.invoiceStatus = _data["invoiceStatus"];
                this.salaryStatus = _data["salaryStatus"];
                (<any>this).articleId = _data["articleId"];
                this.article = _data["article"] ? Article.fromJS(_data["article"]) : <any>undefined;
                if (Array.isArray(_data["carriers"])) {
                    this.carriers = [] as any;
                    for (let item of _data["carriers"])
                        this.carriers!.push(HourRegistrationCarrier.fromJS(item));
                }
                (<any>this).customerId = _data["customerId"];
                this.customer = _data["customer"] ? Customer.fromJS(_data["customer"]) : <any>undefined;
                if (Array.isArray(_data["documentationIds"])) {
                    this.documentationIds = [] as any;
                    for (let item of _data["documentationIds"])
                        this.documentationIds!.push(item);
                }
                (<any>this).rowversion = _data["rowversion"];
            }
        }

        static fromJS(data: any): HourRegistration {
            data = typeof data === 'object' ? data : {};
            let result = new HourRegistration();
            result.init(data);
            return result;
        }

        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["id"] = this.id;
            data["externalId"] = this.externalId;
            data["masterRefId"] = this.masterRefId;
            data["hourDate"] = this.hourDate ? this.hourDate.toISOString() : <any>undefined;
            data["hourCount"] = this.hourCount;
            data["hourPrice"] = this.hourPrice;
            data["hoursInvoiced"] = this.hoursInvoiced;
            data["totalPrice"] = this.totalPrice;
            data["description"] = this.description;
            data["attestationStatus"] = this.attestationStatus;
            data["invoiceStatus"] = this.invoiceStatus;
            data["salaryStatus"] = this.salaryStatus;
            data["articleId"] = this.articleId;
            data["article"] = this.article ? this.article.toJSON() : <any>undefined;
            if (Array.isArray(this.carriers)) {
                data["carriers"] = [];
                for (let item of this.carriers)
                    data["carriers"].push(item.toJSON());
            }
            data["customerId"] = this.customerId;
            data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
            if (Array.isArray(this.documentationIds)) {
                data["documentationIds"] = [];
                for (let item of this.documentationIds)
                    data["documentationIds"].push(item);
            }
            data["rowversion"] = this.rowversion;
            return data;
        }
    }

    export interface IHourRegistration {
        id: number;
        /** Your reference */
        externalId?: string | undefined;
        /** The reference to the master hourRegistration in a group */
        masterRefId?: number | undefined;
        hourDate: Date;
        hourCount?: number | undefined;
        hourPrice?: number | undefined;
        hoursInvoiced?: number | undefined;
        totalPrice?: number | undefined;
        description?: string | undefined;
        attestationStatus: AttestationStatus;
        invoiceStatus: InvoiceStatus;
        salaryStatus: SalaryStatus;
        articleId?: number | undefined;
        article?: Article;
        carriers?: HourRegistrationCarrier[] | undefined;
        customerId?: number | undefined;
        customer?: Customer;
        documentationIds?: string[] | undefined;
        rowversion?: number;
    }

    export class HourRegistrationCarrier implements IHourRegistrationCarrier {
        readonly hourRegistrationId?: number;
        hourRegistration?: HourRegistration;
        carrierId?: number;
        carrier?: Carrier;

        constructor(data?: IHourRegistrationCarrier) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }

        init(_data?: any) {
            if (_data) {
                (<any>this).hourRegistrationId = _data["hourRegistrationId"];
                this.hourRegistration = _data["hourRegistration"] ? HourRegistration.fromJS(_data["hourRegistration"]) : <any>undefined;
                this.carrierId = _data["carrierId"];
                this.carrier = _data["carrier"] ? Carrier.fromJS(_data["carrier"]) : <any>undefined;
            }
        }

        static fromJS(data: any): HourRegistrationCarrier {
            data = typeof data === 'object' ? data : {};
            let result = new HourRegistrationCarrier();
            result.init(data);
            return result;
        }

        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["hourRegistrationId"] = this.hourRegistrationId;
            data["hourRegistration"] = this.hourRegistration ? this.hourRegistration.toJSON() : <any>undefined;
            data["carrierId"] = this.carrierId;
            data["carrier"] = this.carrier ? this.carrier.toJSON() : <any>undefined;
            return data;
        }
    }

    export interface IHourRegistrationCarrier {
        hourRegistrationId?: number;
        hourRegistration?: HourRegistration;
        carrierId?: number;
        carrier?: Carrier;
    }

    export class HourRegistrationCarrierCreate implements IHourRegistrationCarrierCreate {
        carrierId!: number;

        constructor(data?: IHourRegistrationCarrierCreate) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }

        init(_data?: any) {
            if (_data) {
                this.carrierId = _data["carrierId"];
            }
        }

        static fromJS(data: any): HourRegistrationCarrierCreate {
            data = typeof data === 'object' ? data : {};
            let result = new HourRegistrationCarrierCreate();
            result.init(data);
            return result;
        }

        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["carrierId"] = this.carrierId;
            return data;
        }
    }

    export interface IHourRegistrationCarrierCreate {
        carrierId: number;
    }

    export class HourRegistrationCreate implements IHourRegistrationCreate {
        /** Use this as your reference */
        externalId?: string | undefined;
        /** The reference to the master hourRegistration in a group */
        masterRefId?: number | undefined;
        hourDate!: Date;
        hourCount?: number | undefined;
        hourPrice?: number | undefined;
        hoursInvoiced?: number | undefined;
        totalPrice?: number | undefined;
        description?: string | undefined;
        articleId?: number | undefined;
        carriers?: HourRegistrationCarrierCreate[] | undefined;
        customerId?: number | undefined;

        constructor(data?: IHourRegistrationCreate) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }

        init(_data?: any) {
            if (_data) {
                this.externalId = _data["externalId"];
                this.masterRefId = _data["masterRefId"];
                this.hourDate = _data["hourDate"] ? new Date(_data["hourDate"].toString()) : <any>undefined;
                this.hourCount = _data["hourCount"];
                this.hourPrice = _data["hourPrice"];
                this.hoursInvoiced = _data["hoursInvoiced"];
                this.totalPrice = _data["totalPrice"];
                this.description = _data["description"];
                this.articleId = _data["articleId"];
                if (Array.isArray(_data["carriers"])) {
                    this.carriers = [] as any;
                    for (let item of _data["carriers"])
                        this.carriers!.push(HourRegistrationCarrierCreate.fromJS(item));
                }
                this.customerId = _data["customerId"];
            }
        }

        static fromJS(data: any): HourRegistrationCreate {
            data = typeof data === 'object' ? data : {};
            let result = new HourRegistrationCreate();
            result.init(data);
            return result;
        }

        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["externalId"] = this.externalId;
            data["masterRefId"] = this.masterRefId;
            data["hourDate"] = this.hourDate ? this.hourDate.toISOString() : <any>undefined;
            data["hourCount"] = this.hourCount;
            data["hourPrice"] = this.hourPrice;
            data["hoursInvoiced"] = this.hoursInvoiced;
            data["totalPrice"] = this.totalPrice;
            data["description"] = this.description;
            data["articleId"] = this.articleId;
            if (Array.isArray(this.carriers)) {
                data["carriers"] = [];
                for (let item of this.carriers)
                    data["carriers"].push(item.toJSON());
            }
            data["customerId"] = this.customerId;
            return data;
        }
    }

    export interface IHourRegistrationCreate {
        /** Use this as your reference */
        externalId?: string | undefined;
        /** The reference to the master hourRegistration in a group */
        masterRefId?: number | undefined;
        hourDate: Date;
        hourCount?: number | undefined;
        hourPrice?: number | undefined;
        hoursInvoiced?: number | undefined;
        totalPrice?: number | undefined;
        description?: string | undefined;
        articleId?: number | undefined;
        carriers?: HourRegistrationCarrierCreate[] | undefined;
        customerId?: number | undefined;
    }

    export class HourRegistrationDocument implements IHourRegistrationDocument {
        readonly id?: number;
        readonly documentReference?: string | undefined;
        fileName!: string;
        fileData?: string | undefined;
        readonly fileType?: string | undefined;

        constructor(data?: IHourRegistrationDocument) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }

        init(_data?: any) {
            if (_data) {
                (<any>this).id = _data["id"];
                (<any>this).documentReference = _data["documentReference"];
                this.fileName = _data["fileName"];
                this.fileData = _data["fileData"];
                (<any>this).fileType = _data["fileType"];
            }
        }

        static fromJS(data: any): HourRegistrationDocument {
            data = typeof data === 'object' ? data : {};
            let result = new HourRegistrationDocument();
            result.init(data);
            return result;
        }

        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["id"] = this.id;
            data["documentReference"] = this.documentReference;
            data["fileName"] = this.fileName;
            data["fileData"] = this.fileData;
            data["fileType"] = this.fileType;
            return data;
        }
    }

    export interface IHourRegistrationDocument {
        id?: number;
        documentReference?: string | undefined;
        fileName: string;
        fileData?: string | undefined;
        fileType?: string | undefined;
    }

    export class HourRegistrationDocumentCreate implements IHourRegistrationDocumentCreate {
        fileName!: string;
        fileData!: string;
        hourRegistrationId!: number;

        constructor(data?: IHourRegistrationDocumentCreate) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }

        init(_data?: any) {
            if (_data) {
                this.fileName = _data["fileName"];
                this.fileData = _data["fileData"];
                this.hourRegistrationId = _data["hourRegistrationId"];
            }
        }

        static fromJS(data: any): HourRegistrationDocumentCreate {
            data = typeof data === 'object' ? data : {};
            let result = new HourRegistrationDocumentCreate();
            result.init(data);
            return result;
        }

        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["fileName"] = this.fileName;
            data["fileData"] = this.fileData;
            data["hourRegistrationId"] = this.hourRegistrationId;
            return data;
        }
    }

    export interface IHourRegistrationDocumentCreate {
        fileName: string;
        fileData: string;
        hourRegistrationId: number;
    }

    export enum InvoiceStatus {
        ToBeInvoiced = "toBeInvoiced",
        NoInvoice = "noInvoice",
        Approved = "approved",
        Rejected = "rejected",
    }

    export class JsonPatchOperation implements IJsonPatchOperation {
        op?: JsonPatchOperationType | undefined;
        value?: any | undefined;
        /** Only used in move */
        from?: any | undefined;
        path?: string;

        constructor(data?: IJsonPatchOperation) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }

        init(_data?: any) {
            if (_data) {
                this.op = _data["op"];
                this.value = _data["value"];
                this.from = _data["from"];
                this.path = _data["path"];
            }
        }

        static fromJS(data: any): JsonPatchOperation {
            data = typeof data === 'object' ? data : {};
            let result = new JsonPatchOperation();
            result.init(data);
            return result;
        }

        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["op"] = this.op;
            data["value"] = this.value;
            data["from"] = this.from;
            data["path"] = this.path;
            return data;
        }
    }

    export interface IJsonPatchOperation {
        op?: JsonPatchOperationType | undefined;
        value?: any | undefined;
        /** Only used in move */
        from?: any | undefined;
        path?: string;
    }

    export enum JsonPatchOperationType {
        Add = "add",
        Remove = "remove",
        Replace = "replace",
        Move = "move",
        Copy = "copy",
        Test = "test",
    }

    export class ProblemDetails implements IProblemDetails {
        type?: string | undefined;
        title?: string | undefined;
        status?: number | undefined;
        detail?: string | undefined;
        instance?: string | undefined;

        constructor(data?: IProblemDetails) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }

        init(_data?: any) {
            if (_data) {
                this.type = _data["type"];
                this.title = _data["title"];
                this.status = _data["status"];
                this.detail = _data["detail"];
                this.instance = _data["instance"];
            }
        }

        static fromJS(data: any): ProblemDetails {
            data = typeof data === 'object' ? data : {};
            let result = new ProblemDetails();
            result.init(data);
            return result;
        }

        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["type"] = this.type;
            data["title"] = this.title;
            data["status"] = this.status;
            data["detail"] = this.detail;
            data["instance"] = this.instance;
            return data;
        }
    }

    export interface IProblemDetails {
        type?: string | undefined;
        title?: string | undefined;
        status?: number | undefined;
        detail?: string | undefined;
        instance?: string | undefined;
    }

    export class Project implements IProject {
        readonly id!: number;
        startDate!: Date;
        carrier!: Carrier;
        endDate?: Date | undefined;
        actualEndDate?: Date | undefined;
        contractSum?: number | undefined;
        description?: string | undefined;
        customer?: Customer;
        projectLeader?: Carrier;
        readonly rowversion!: number;

        constructor(data?: IProject) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
            if (!data) {
                this.carrier = new Carrier();
            }
        }

        init(_data?: any) {
            if (_data) {
                (<any>this).id = _data["id"];
                this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
                this.carrier = _data["carrier"] ? Carrier.fromJS(_data["carrier"]) : new Carrier();
                this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
                this.actualEndDate = _data["actualEndDate"] ? new Date(_data["actualEndDate"].toString()) : <any>undefined;
                this.contractSum = _data["contractSum"];
                this.description = _data["description"];
                this.customer = _data["customer"] ? Customer.fromJS(_data["customer"]) : <any>undefined;
                this.projectLeader = _data["projectLeader"] ? Carrier.fromJS(_data["projectLeader"]) : <any>undefined;
                (<any>this).rowversion = _data["rowversion"];
            }
        }

        static fromJS(data: any): Project {
            data = typeof data === 'object' ? data : {};
            let result = new Project();
            result.init(data);
            return result;
        }

        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["id"] = this.id;
            data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
            data["carrier"] = this.carrier ? this.carrier.toJSON() : <any>undefined;
            data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
            data["actualEndDate"] = this.actualEndDate ? this.actualEndDate.toISOString() : <any>undefined;
            data["contractSum"] = this.contractSum;
            data["description"] = this.description;
            data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
            data["projectLeader"] = this.projectLeader ? this.projectLeader.toJSON() : <any>undefined;
            data["rowversion"] = this.rowversion;
            return data;
        }
    }

    export interface IProject {
        id: number;
        startDate: Date;
        carrier: Carrier;
        endDate?: Date | undefined;
        actualEndDate?: Date | undefined;
        contractSum?: number | undefined;
        description?: string | undefined;
        customer?: Customer;
        projectLeader?: Carrier;
        rowversion: number;
    }

    export class ProjectCarrierCreate implements IProjectCarrierCreate {
        name!: string;
        key!: string;

        constructor(data?: IProjectCarrierCreate) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }

        init(_data?: any) {
            if (_data) {
                this.name = _data["name"];
                this.key = _data["key"];
            }
        }

        static fromJS(data: any): ProjectCarrierCreate {
            data = typeof data === 'object' ? data : {};
            let result = new ProjectCarrierCreate();
            result.init(data);
            return result;
        }

        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["name"] = this.name;
            data["key"] = this.key;
            return data;
        }
    }

    export interface IProjectCarrierCreate {
        name: string;
        key: string;
    }

    export class ProjectCreate implements IProjectCreate {
        startDate!: Date;
        endDate?: Date | undefined;
        actualEndDate?: Date | undefined;
        contractSum?: number | undefined;
        description?: string | undefined;
        customerId?: number | undefined;
        projectLeaderCarrierId?: number | undefined;
        carrier?: ProjectCarrierCreate;

        constructor(data?: IProjectCreate) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }

        init(_data?: any) {
            if (_data) {
                this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
                this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
                this.actualEndDate = _data["actualEndDate"] ? new Date(_data["actualEndDate"].toString()) : <any>undefined;
                this.contractSum = _data["contractSum"];
                this.description = _data["description"];
                this.customerId = _data["customerId"];
                this.projectLeaderCarrierId = _data["projectLeaderCarrierId"];
                this.carrier = _data["carrier"] ? ProjectCarrierCreate.fromJS(_data["carrier"]) : <any>undefined;
            }
        }

        static fromJS(data: any): ProjectCreate {
            data = typeof data === 'object' ? data : {};
            let result = new ProjectCreate();
            result.init(data);
            return result;
        }

        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
            data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
            data["actualEndDate"] = this.actualEndDate ? this.actualEndDate.toISOString() : <any>undefined;
            data["contractSum"] = this.contractSum;
            data["description"] = this.description;
            data["customerId"] = this.customerId;
            data["projectLeaderCarrierId"] = this.projectLeaderCarrierId;
            data["carrier"] = this.carrier ? this.carrier.toJSON() : <any>undefined;
            return data;
        }
    }

    export interface IProjectCreate {
        startDate: Date;
        endDate?: Date | undefined;
        actualEndDate?: Date | undefined;
        contractSum?: number | undefined;
        description?: string | undefined;
        customerId?: number | undefined;
        projectLeaderCarrierId?: number | undefined;
        carrier?: ProjectCarrierCreate;
    }

    export enum SalaryStatus {
        Pending = "pending",
        Approved = "approved",
        Rejected = "rejected",
    }

    export class StreetAddress implements IStreetAddress {
        address1!: string;
        address2?: string | undefined;
        address3?: string | undefined;
        readonly isForeign?: boolean;
        zipCodeKey?: string | undefined;
        readonly zipCodeName?: string | undefined;
        country?: string | undefined;

        constructor(data?: IStreetAddress) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }

        init(_data?: any) {
            if (_data) {
                this.address1 = _data["address1"];
                this.address2 = _data["address2"];
                this.address3 = _data["address3"];
                (<any>this).isForeign = _data["isForeign"];
                this.zipCodeKey = _data["zipCodeKey"];
                (<any>this).zipCodeName = _data["zipCodeName"];
                this.country = _data["country"];
            }
        }

        static fromJS(data: any): StreetAddress {
            data = typeof data === 'object' ? data : {};
            let result = new StreetAddress();
            result.init(data);
            return result;
        }

        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["address1"] = this.address1;
            data["address2"] = this.address2;
            data["address3"] = this.address3;
            data["isForeign"] = this.isForeign;
            data["zipCodeKey"] = this.zipCodeKey;
            data["zipCodeName"] = this.zipCodeName;
            data["country"] = this.country;
            return data;
        }
    }

    export interface IStreetAddress {
        address1: string;
        address2?: string | undefined;
        address3?: string | undefined;
        isForeign?: boolean;
        zipCodeKey?: string | undefined;
        zipCodeName?: string | undefined;
        country?: string | undefined;
    }

    export class WageType implements IWageType {
        id?: number;
        typeId?: number;
        typeName?: string | undefined;

        constructor(data?: IWageType) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }

        init(_data?: any) {
            if (_data) {
                this.id = _data["id"];
                this.typeId = _data["typeId"];
                this.typeName = _data["typeName"];
            }
        }

        static fromJS(data: any): WageType {
            data = typeof data === 'object' ? data : {};
            let result = new WageType();
            result.init(data);
            return result;
        }

        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["id"] = this.id;
            data["typeId"] = this.typeId;
            data["typeName"] = this.typeName;
            return data;
        }
    }

    export interface IWageType {
        id?: number;
        typeId?: number;
        typeName?: string | undefined;
    }

    export class ApiException extends Error {
        message: string;
        status: number;
        response: string;
        headers: { [key: string]: any; };
        result: any;

        constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
            super();

            this.message = message;
            this.status = status;
            this.response = response;
            this.headers = headers;
            this.result = result;
        }

        protected isApiException = true;

        static isApiException(obj: any): obj is ApiException {
            return obj.isApiException === true;
        }
    }

    function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
        if (result !== null && result !== undefined)
            throw result;
        else
            throw new ApiException(message, status, response, headers, null);
    }

}